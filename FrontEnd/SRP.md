# SRP

## What is SOLID

소프트웨어 설계 5원칙으로서 5가지 원칙의 앞글자를 따온 단어이다.

실무단의 아키텍처 설계부터 코딩과 리뷰까지 두루두루 사용되는 원칙으로서 `SRP-단일 책임 원칙`에 대해선 리액트 공식 문서에도 언급되는 등 다양한 곳에서 언급되기 때문에 대부분의 개발자가 어떤 경로에서든 한번쯤은 접해봤을 것이다.


- <span style="color:red">S</span>RP : Single Responsibility Principle
- <span style="color:orange">O</span>CP : Open/Closed Principle
- <span style="color:yellow">L</span>SP : Liskov Substitution Principle
- <span style="color:#C0FFFF">I</span>SP : Interface Segregation Principle
- <span style="color:violet">D</span>IP : Dependency Inversion Principle


코드를 변경해야 하는 요구사항은 사람 간의 커뮤니케이션으로부터 접수되고, 변화하는 시장 상황에 맞게 요구사항도 계속 변경되기 마련이다. 이때 이상적인 소프트웨어 구조는 변경된 요구사항이 전달되었을 때 다른 컴포넌트에 영향(side-effect)이 가지 않도록 딱 원하는 부분만 변경할 수 있는, 응집도가 높고 결합도가 낮은 컴포넌트의 집합 구조이다.

SOLID 원칙 중 소프트웨어 구조를 조직의 커뮤니케이션 구조와 유사하게 만들 수 있도록 도와주는 원칙인 `SRP 원칙`에 대해 알아보자

<br />


## SRP : Single Responsibility Principle

<img width="1354" alt="image" src="https://github.com/livable-final/client/assets/83483378/7b8dff5a-f127-465d-b467-000f643909c4">

SRP를 직역하자면 `단일 책임 원칙`으로 일컫는다.

대부분의 사람들은 이를 단일한 `동작만` 가지도록 분리되고 쪼개진 컴포넌트로 생각하기도 한다.

섣불리 코딩 기법으로 접근하면 ‘책임=동작’ 공식으로 잘못 해석하기도 한다. 

하지만 우리는 `책임` 이라는 키워드에 집중할 필요가 있다. 

그럼 SRP는 어떤 원칙일까? 로버트 C. 마틴은 SRP에 대해 아래처럼 강하게 얘기하고 있다

> “SRP의 최종 버전은 다음과 같다. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.” - 로버트 C. 마틴(클린 아키텍처)

모듈은 컴포넌트로 볼 수 있고 액터는 사용자 또는 이해관계자 집단을 의미한다. 중요한 점은 SRP의 ‘책임’이 의미하는 것을 소프트웨어 내부의 ‘동작’ 이나 ‘논리’가 아니라 조직 간 커뮤니케이션 영역으로 봐야 한다는 점이다.

---

동작으로 쪼개다 보면 그 기준이 애매하기도 하고 과할 정도로 자잘하게 컴포넌트가 쪼개질 수 있다. 컴포넌트를 너무 자잘하게 쪼개면 전체 로직을 한눈에 파악하기 어렵게 만들고 코드 네비게이션에 들어가는 공수를 늘어나게 만듭니다. 단일한 동작을 갖도록 코딩하는 것은 `컴포넌트` 가 아니라 `순수한 함수 한정`이 되어야 한다. 이는 SRP라는 원칙으로 도달할 아키텍처 영역이라기보다는 클린 코드의 영역으로 볼 수 있다.


### 디자인 책무에서의 단일 책임

```
안녕하세요 UI/UX팀 CU입니다. 뷰어엔드 댓글의 신고하기 버튼을 눌렀을 때 나오는 모달의 체크박스를 선택했을 때의 
"선택됨" 색상을 다크모드에 맞게 바꿔야되는데요, 이 "선택됨" 색상을 누구한테 문의드리면 될까요?
```

디자인에서 바라보는 화면과 실제 개발되는 컴포넌트의 구조가 다르다는 것은 유지보수 측면에서 매우 큰 허들이 된다.

다중 책임의 커뮤니케이션 구조는 공통 컴포넌트 없이 다른 화면을 각자 따로 디자인하는 방식이었기 때문에 화면별로 상이한 체크박스가 존재하게 되고, 하나를 바꾼다고 해도 다른 체크박스에는 반영이 되지 않아 사실상 `공통` 요소라는 것이 존재하지 않게 되어 디자인, 개발, QA 모두에게 고통이 된다.

![image](https://github.com/livable-final/client/assets/83483378/9c25481a-9472-46ae-a56e-761b10fc6383)


아토믹 디자인은 UI영역의 SRP를 만족할 수 있게 해주는 아주 고마운 개념이다. Atom, Molecule, Organism, Template, Page 각각이 하나의 책임(책무)를 담당할 수 있도록 구조화를 진행한다. 

즉 디자인 컴포넌트와 1:1로 매치되는 컴포넌트를 만드는 것이다. 여기엔 네이밍, variant, 마진, 패딩 모두가 포함된다. 컴포넌트의 내부 패딩이나 컴포넌트 간 마진 또한 디자인 책무에서 단일하게 책임져야하는 부분이다.

> 디자인 시스템을 적용한 이후

```
안녕하세요 웹팀 스티브입니다. 체크박스(피그마 링크) 다크모드 대응이 필요해 문의 드렸습니다.
```


---

### 개발 책무에서의 단일 책임

<img width="860" alt="image" src="https://github.com/livable-final/client/assets/83483378/8289f746-7630-48fc-b3ac-9aad2d827c72">


<br />
<br />

위 컴포넌트는 컴포넌트 명에서 알 수 있듯이, 활성화된 유저의 목록을 렌더링하는 컴포넌트이다.

하지만 서버에서 `user` 데이터를 가져오는 기능과 `User` 데이터 정보 중 활성화된 유저를 필터링하는 기능까지 다중 책임을 가지고 있다.

<img width="864" alt="image" src="https://github.com/livable-final/client/assets/83483378/d85fd421-0649-489a-a251-bc27428956ad">




<br />
<br />
<br />

#### 1. 데이터 페칭 기능 분리

<img width="750" alt="image" src="https://github.com/livable-final/client/assets/83483378/4a6f4d8b-477b-47c7-83fe-7b1b598ad029">


`useEffect` `useState`를 통해 데이터 페칭하는 로직을 커스텀 훅으로 분리했다.

이로서 활성화된 유저의 데이터를 받아오고 필터링하여 렌더링하는 컴포넌트에서, 데이터를 받아오는 책임을 분리하였다

---


#### 2. 필터링 기능 분리

<img width="690" alt="image" src="https://github.com/livable-final/client/assets/83483378/f4393ac6-da48-4d37-a50b-3f45e213af33">


활성화된 유저를 필터링하는 로직을 분리하였다. 

이로서 활성화된 유저를 필터링하여 렌더링하는 컴포넌트에서, 

`활성화된 유저들의 목록을 렌더링` 하는 책임을 가진 컴포넌트가 되었다.
