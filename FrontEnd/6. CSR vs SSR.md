# Front-End

## Client Side Rendering(CSR) vs Server Side Rendering(SSR)

### 렌더링

![image](https://github.com/1017yu/this-is-money/assets/83483378/fd1957fa-b777-41e5-895a-70e9e25ffd4f)

모바일의 시대가 도래하면서, 모바일 환경에 맞춰진 웹 페이지 즉 모바일 웹에 대한 니즈가 폭발적으로 증가했고 그에 따른 성능 이슈도 함께 거론되었다.

데스크탑에 비해 성능이 낮은 모바일, 스마트폰을 통해 웹 페이지를 출력하기 위해서는 기존에 있었던 방식과는 다른 접근이 필요했고 그에 따라서 Single Page web Application 기법(SPA)이 등장하게 되었다.

![image](https://github.com/1017yu/this-is-money/assets/83483378/a62dca30-bb1d-429d-82d7-57b21305593c)

SPA는 브라우저에 로드되고 난 뒤에 페이지 전체를 서버에 요청하는 것이 아니라 최초 한번 페이지 전체를 로딩한 이후 부터는 데이터만 변경하여 사용할 수 있는 웹 애플리케이션을 의미한다.

전통적인 웹 방식( 서버 사이드 렌더링 )은 이 SPA 방식에 비해 성능 문제를 보였다. 요청 시 마다 새로고침이 일어나며 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링하는 방식이였기 때문이다.

SPA는 트래픽을 감소시키고 사용자에게 더 나은 경험을 제공했다. 서버는 단지 JSON 파일만 보내주는 역할을 했고, html을 그리는 역할은 클라이언트 측에서 자바스크립트가 수행하게 된 것이다.

바로 이것이 **클라이언트 사이드 렌더링** 이다.

---

### CSR의 등장과 장점

<img width="823" alt="image" src="https://github.com/1017yu/this-is-money/assets/83483378/e3476524-8c0d-4d0a-b5f2-8658b4c9c58a">

**클라이언트 사이드 렌더링**은 웹 페이지의 렌더링이 클라이언트(브라우저) 측에서 일어나는 것을 의미한다.

유저가 웹사이트 요청을 보내면 CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.

브라우저는 최초 요청에서 HTML, JS, CSS 확장자의 파일을 차례로 다운로드한다.
<br />

JS 파일의 다운로드가 완료된 다음, 해당 JS 파일이 DOM을 빈 HTML 위에 그리기 시작한다.
<br />

즉, 최초 호출 때만 HTML, JS, CSS를 요청하고, 이후에는 화면에서 변화가 일어나야 하는 만큼의 데이터만 요청하게 된다. (ex. JSON)
<br />

라우팅(새로운 페이지로 이동)을 하더라도 HTML 자체가 바뀌는 것이 아니라 JS 차원에서 새로운 화면을 그려내는 것이다.

---

### CSR의 단점

1. **초기 구동 속도가 느리다** - CSR은 페이지를 읽어들이는 시간, JS를 읽어들이는 시간, JS가 화면을 그리는 시간까지 모두 마쳐야 화면에 콘텐츠가 사용자에게 보여진다. 여기에 웹 서버에서 컨텐츠 데이터라도 가져와야 한다면, 그 소요시간은 더욱 길어진다.

2. **SEO(검색 엔진 최적화) 문제가 존재** - 대부분의 웹 크롤러, 봇들이 자바스크립트 파일을 실행시키지 못한다. 때문에 HTML 에서만 콘텐츠를 수집하게 되고 클라이언트 사이드 렌더링되는 페이지를 빈 페이지로 인식하게 된다.

3. **보안 문제가 생길 수 있다** - 사용자 정보를 서버 측에서 세션으로 관리하는 SSR 방식과 달리, 클라이언트 측에는 쿠키말고는 사용자에 대한 정보를 저장할 공간이 마땅치 않다.

(로컬 스토리지 - 데이터 노출)

(세션 스토리지 - 브라우저를 닫으면 모두 사라짐)

(쿠키 - 클라이언트 측에서 조작이 가능)

---

### SEO 문제와 SSR의 재등장

SEO 문제는 SSR을 다시 등장시키는 이유 중 하나였다.

웹 크롤러가 각 사이트를 돌아다니며 조사를 한다고 가정해보자

**_CSR_**

1. 낙낙! 계세요?
2. 조용히 문이 열린다 - 페이지 요청
3. 안에 계세요? - 빈 집 -> 첫 페이지
4. 조사 못하고 구글 봇 퇴장
5. 이제서야 JS 파일이 다운로드 되며 페이지 로드 -> 이미 크롤러는 떠나감

<검색 노출 안됨>

<br />

**_SSR_**

1. 낙낙! 계세요?
2. (주인이 웹 크롤러를 맞이하며) 어서오세요! 저희 페이지는 ... -> 첫 페이지
3. 조사를 마치고 구글 못 퇴장

<검색 노출 완료>

---

### SSR (Server Side Rendering)

위에서 언급했던 CSR과 SSR의 차이에서 알 수 있듯이, SSR은 서버에서 첫 페이지의 렌더링을 클라이언트 측이 아닌 서버 측에서 처리해주는 방식이다.

![image](https://github.com/1017yu/this-is-money/assets/83483378/a0b3eb27-9490-4da7-b004-b95cd23f108b)

1. UX 측면에서 강점

- CSR에 비해 페이지 구성 속도는 늦어질 수도 있지만, 전체적으로 사용자에게 보여지는 콘텐츠 구성이 완료되는 시점은 빨라진다.
- 불필요한 JS 번들 파일을 받아오지 않고, 서버 단에서 첫 페이지에 필요한 정적인 부분만 처리한 뒤, JS는 나중에 필요한 부분만 필요할 때 로드

2. SEO 측면에서 유리

- 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 보여주는 방식이기 때문에 CSR의 단점인 "첫 페이지 깡통" 상태를 극복할 수 있다.

---

### SSR + CSR

분명 SSR은 2세대 기술이고, 3세대의 기술인 CSR에 한계를 느껴 2세대로 회귀하는 것이 맞는가..? 다시 MPA로 구현해야하는가?

우리는 SSR의 장점과 CSR의 장점만 조합하여 사용하는 세대가 되었다.

CSR의 한계점인 초기 로딩의 속도 문제와 검색 엔진 최적화를 SSR로 해결하고, 서버 과부하를 CSR로 해결하면 될 것이다!

즉, 초기 로딩 속도와 SEO에 강점을 가진 SSR을 사용하면서, 상호작용성과 SPA 개발의 편의성을 갖는 CSR을 적절하게 혼합하여 최적화된 사용자 경험을 제공해야 한다.

---

### 그래서 등장한 NEXT.JS

![image](https://github.com/1017yu/this-is-money/assets/83483378/7b5e6da1-6af5-45ce-9b27-76b3470d40dc)

1. 최초 렌더링 시 SSR 사용:

사용자가 해당 페이지를 처음 방문할 때, 서버 측에서 페이지를 렌더링하고 완성된 HTML을 클라이언트로 전달한다.
<br />
About 컴포넌트의 data props는 서버에서 초기 데이터를 가져온 것이다.

Link 컴포넌트의 `href` 속성은 `/`로 설정되어 있으므로, 사용자가 about 링크를 클릭하면 홈 페이지로 이동하게 된다.

```
import React from "react";
import Link from "next/link"; // Link 사용하여 라우팅 -> CSR

export default function About({ data }) {
  return (
    <div>
      <Link href="/">about</Link> {data}
    </div>
  );
}

```

2. about 페이지를 방문시 CSR 사용:

사용자가 about 링크를 클릭하여 about 페이지로 이동할 때, 브라우저에서는 서버에 새로운 페이지를 요청하지 않고 CSR 통해 페이지를 렌더링한다. (about.js만 요청)
