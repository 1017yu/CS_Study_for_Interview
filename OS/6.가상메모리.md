# OS

## Virtual Memory System

<br/>

### Memory

- 메모리(memory)란?
  - 메모리란 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치
    - 내부 기억장치: 주기억장치
      - RAM,CPU 안에 있는 레지스터와 캐쉬 등
    - 외부 기억장치: 보조 기억장치
      - SSD,HDD 등

<br/>

- 가상 메모리의 등장 배경
  - 초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했고 그렇지 않을 경우 "메모리 부족" 오류에 의해 해당 애플리케이션을 실행할 수 없는 문제 발생
  - 이후 프로그래머가 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할 수 있게 하는 오버레이 기법을 사용하여 메모리 부족 문제를 해결하고자함
  - 하지만 이 역시 전반적인 메모리 부족 문제를 해결할 수 없었음. 오버레이를 사용하는 프로그램은 그렇지 않은 프로그램보다는 메모리를 덜 사용했지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 **결국 똑같은 메모리 부족 오류가 발생함**
  - 여기에서 더 발전한 **가상 메모리 기법**은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 **최소한 얼마만큼의 메모리가 필요한가에 집중**하여 문제를 해결하고자 함.
    - 이렇게 접근하는 방식이 가능한 이유는, 메모리 접근은 순차적이고 지역화되어 있기 때문
    - 애플리케이션의 일부분만 메모리(기억장치)에 올려진다면, 메모리에 올라가지 않는 나머지는 어디에 위치해야 할까? ⇒ 정답은 보조 기억장치, 즉 디스크에 저장됨
    - 따라서 가상메모리의 핵심은 보조 기억장치이다

<br/><br/>

---

<br/>

- 가상메모리(virtual memory, virtual storage)
  <img width="200" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/089bb619-9253-43b7-ac7d-30de7a36b5e0">

  > 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다

  - 가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안
  - 가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.
  - 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하는 것
  - 가상적으로 주어진 주소를 가상 주소(virtual address) 또는 논리 주소(logical address) 라고 하며, 실제 메모리 상에서 유효한 주소를 물리 주소(physical address) 또는 실주소(real address)라고 한다
  - 가상 주소의 범위를 가상 주소 공간, 물리 주소의 범위를 물리 주소 공간이라고 한다.
  - 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간(Heap영역, Stack 영역, 코드, 데이터)의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

    <img width="459" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/4b206ed8-6b48-4667-8f5c-1f2ce35243fe">

  <br/>
  <br/>

- MMU(Memory Management Unit)
  <img width="800" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/39e2f0bd-f30f-4529-afc3-503d339a38ce">

  - 메모리 관리 장치
  - MMU의 기능
    - 가상주소를 물리주소로 변환하고, 메모리를 보호하는 기능을 수행함
    - cpu가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨
    - 메모리를 일일이 가상 주소에서 물리적 주소로 번역하게 되면 작업 과부화가 올 수 있으므로 MMU는 RAM을 여러 부분(페이지)로 나누어 각 페이지를 하나의 독립된 항목으로 처리함
    - 페이지 및 주고 번역 정보를 기억하는 작업이 가상 메모리 구현시 결정적 절차
    - 각 프로그램에 **실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식**
    - 가상 메모리 주소와 실제 메모리 주소 사이의 변환을 위해 변환 참조 버퍼(Translation Lookaside Buffer, TLB)라는 고속의 보조기억장치를 참조하는데 TLB에 원하는 변환 정보가 없을때는 더 느린 방법으로 페이지 변환 정보를 얻어오는데, 이 페이지 변환 정보가 담겨 있는 자료구조를 페이지 테이블(Page TAble)이라고 한다
    - TLB나 페이지 테이블이 실제 메모리 주소를 가져오지 못하는 경우가 있는데, 이를 페이지 실패(page fault)라 한다. 대부분의 경우 페이지 실패는 가상 주소공간의 페이지가 실제 메모리에 없기 때문에 발생한다. 이 경우 운영체제가 그 처리를 담당하는데, 비어 있는 메모리 공간에 페이지를 할당하거나, 비어 있는 메모리 공간이 없을 경우 실제 메모리의 한 페이지를 빼내 하드 디스크에 저장하고 (이를 페이징이라 한다) 그 자리에 요구 받은 페이지를 할당한다

<br/><br/>

- 페이징(paging)

![image](https://github.com/OP-AL/opal/assets/125563995/d22db57f-5f80-44b1-a5f5-3479b100fa20)

- 고정 크기로 분할된 페이지를 통해 가상 메모리를 관리하는 기법
  - 페이지(Page): 가상 메모리를 고정 크기로 나눈 블록
  - 프레임(frame): 실제 메모리를 페이지와 같은 크기로 나눈 블록 (= 페이지 프레임)
- 프레임과 페이지는 메모리를 일정한 크기의 공간으로 나누어 관리하는 단위이며 프레임과 페이지의 크기는 같다
- frame의 크기와 Page의 크기가 동일하기 때문에 외부단편화가 발생하지 않는다.
- 페이지와 프레임간의 관계
  - Vitual Memory의 page가 하나의 frame을 할당 받으면, 물리 메모리에 위치하게 된다
  - 프레임을 할당 받지 못한 페이지들은 외부 저장장치에 저장되며, 이때도 프레임과 같은 크기 단위로 관리된다.
- Demand Paging(요구 페이징)
  - 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며, 가상 메모리 시스템에서 많이 사용된다.
  - 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질때 페이지들이 적재된다
  - 따라서 한번도 접급되지 않은 페이지는 물리 메모리에 적재되지 않는다
    <br/><br/>
- 페이지 교체

  - 요구 페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 Page fault(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다
  - 이때 **물리메모리가 모두 사용중인 상황이면, 페이지 교체가 이루어져야 한다**
  - 물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름
    - 디스크에서 필요한 페이지의 위치를 찾는다
    - 빈 페이지 프레임을 찾는다
      - 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다
      - 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다
    - 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다
    - 사용자 프로세스 재시작<br/><br/> <br/><br/>
  - 페이지 교체 알고리즘

    - 무작위

      - 무작위로 대상 페이지를 선정하여 내보냄

    - FIFO
      <img width="790" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/b2fcd639-4351-4039-9be9-f860c9f89bb2">

      - 가장 간단한 페이지 교체 알고리즘 first in first out 즉, 먼저 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다
      - 장점, 이해하기 쉽고, 프로그램하기 쉬움
      - 단점
        - 오래된 페이지가 항상 불필요하지 않는 정보를 포함하지 않을 수 있다 (초기변수등)
        - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다
        - Belady의 모순: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다 <br/><br/><br/><br/>

    - 최적 페이지 교체 (Optimal Page Replacement) <이론적- 구현이 힘들다>
      <img width="812" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/d3f64c61-2c36-4085-b202-212cc1dd8888">

      - Belady의 모순을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 Belady의 모순이 발생하지 않는다. 이 알고리즘의 핵심은 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것이다. 주로 비교 연구 목적을 위해 사용한다
      - 장점
        - 알고리즘 중 가장 낮은 페이지 부재율을 보장함
        - 가장 이상적 방식
      - 단점

        - 구현의 어려움 > 모든 프로세스의 메모리 참조 계획을 미리 파악할 방법이 없기 때문 <br/><br/><br/><br/>

        <img width="799" alt="image" src="https://github.com/OP-AL/opal/assets/125563995/4fbc37a4-224b-4368-b4ef-5b562cc270ab">

    - LRU 페이지 교체(LRU Page Replacement) <최적 근접 알고리즘
      - LRU: Least Recently Used
      - 최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
      - 가장 오랫동안 사용하지 않은 페이지를 교체하는 방식 (시간 지역성 고려 : 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질)
      - 대체적으로 FIFO 알고리즘보다 우수하고, OPT알고리즘보다는 그렇지 못한 모습을 보인다
    - LFU 페이지 교체(LFU Page Replacement)
      - LFU: Least Frequently Used
      - 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘
      - 특징
        - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
        - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다
    - MFU 페이지 교체(MFU Page Replacement)
      - MFU: Most Frequently Used
      - 가장 많이 사용된 페이지가 앞으로는 사용되지 않을것이라 판단하고 교체하는 방식
      - 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다
      - 특징
        - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.
