# OS

## 메모리 관리 전략

<br />

---

## 1. 메모리 관리 배경

<img width="670" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/6a83adb3-6753-4aee-947c-10f7e65d14ea">

프로세스 간 독립된 메모리 공간을 유지하는 것은 효율적인 메모리 관리의 핵심 원칙 중 하나이다. <br /> 각각의 <b>프로세스</b> 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, `운영체제` 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

<br />

-> 이로 인해 다른 프로세스가 자신의 메모리를 손상시키는 등의 문제가 방지된다.

<br />

 운영 체제는 프로세스의 메모리 관리를 책임지며, 이를 위해 가상 메모리가 등장하게 된다.
<br />
가상 메모리는 프로세스에게 실제 물리적 메모리를 할당하는 것이 아니라, 각 프로세스에게 독립된 가상 주소 공간을 제공한다. 이 가상 주소 공간은 프로세스에게는 실제 메모리처럼 보이지만, 실제로는 물리적인 메모리와 매핑되는 것입니다.

즉 아래에서 설명할 효율적인 메모리 관리 기법은 가상 메모리를 효율적으로 관리하게 되는 것이다.

이러한 메모리 관리 기법은 각 프로세스가 필요한 만큼의 메모리를 할당하고, 메모리의 효율적인 사용을 도모하여 다중 프로그래밍 환경에서 여러 프로세스가 동시에 실행될 수 있도록 한다.


---

## 2. 효율적인 메모리 관리 기법

### 1. Swapping : 메모리의 관리를 위해 사용되는 기법.

<img width="662" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/827eeb70-78d7-4579-9ae9-e3f34cb777db">

표준 Swapping 방식으로는 다중 프로그래밍 환경에서 `CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.` <br /><br />
주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out 이라 한다. swap 에는 `큰 디스크 전송시간`이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.
<br /><br />

**큰 전송시간?**

- 메모리 부족 상황에서는 운영 체제가 메모리에 저장된 프로세스의 일부 데이터를 디스크로 이동시키고, 그 데이터를 스왑 메모리에 저장한다.
- 메인 메모리가 부족한 상황에서 디스크를 사용하여 데이터를 스왑하는 것은 운영 체제가 추가적인 가상 메모리 공간을 제공하고 시스템의 안정성을 유지하는 데 도움이 된다.

<br />
<br />

---

### 2. 단편화 (Fragmentation)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, `프로세스들이 차지하는 메모리 틈` 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 `단편화` 이다. 단편화는 두가지 종류로 나뉜다.

 
 <br />
 

<img width="668" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/60a9a955-64bf-479a-ad47-75e20ec064d9">

2-1.  외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분.
    <br /> <br />
    일반적으로 운영체제는 프로세스에게 필요한 메모리 공간을 할당하기 위해 메모리를 작은 조각으로 나누어 사용한다.
    <br />
    하지만 프로세스가 종료되거나 메모리 공간이 해제되면, 이 작은 조각들이 남게 되는데 이를 자유 공간이라고 칭한다.
    <br/> 이 자유 공간들은 다른 프로세스들이 메모리를 요청할 때 사용될 수 있어야 하지만, 이 자유 공간들이 분산되어 있으면 충분한 크기의 연속된 메모리 공간을 확보하기 어려워 외부 단편화가 발생한다고 볼 수 있다.

<br />
<br />

---


<img width="611" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/40225a8f-b2ec-45b9-9051-759b17c1568f">

2-2. 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분
   <br />
   <br />
   내부 단편화는 프로세스가 할당받은 메모리 공간 안에 남는 부분을 칭한다. <br />
   메모리를 일정 크기로 분할하여 할당할 때, 프로세스가 사용하는 메모리 공간보다 더 큰 크기의 공간을 할당받을 수 있다.
   <br />
   이렇게 되면 실제로 필요한 공간보다는 낭비가 발생하게 되는데, 이러한 차이를 내부 단편화라고 할 수 있다.
   <br />
   <br />
   예를 들어, 자유 공간이 10,000 바이트 (B) 있고, 프로세스 A가 9,998B의 메모리를 사용하면 2B의 차이가 발생한다.
   <br />
   이 차이는 프로세스 A가 필요로 하는 메모리보다 더 많은 메모리를 할당받은 결과이며, 이는 내부 단편화로 간주한다.

<br />
<br />

---

<img width="668" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/7b69f5b9-e0db-42b8-b085-cb7269959b5a">

- 2-3 압축
  <br />
  외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다.

<br />
<br />

---

### 3. Paging(페이징)

<img width="671" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/3567d145-0118-485a-8f80-9075c1ed6031">

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 ```고정 크기로``` 분리되어 있고, 프로세스는 페이지라 불리는 ```고정 크기```의 블록으로 분리된다.

페이징 기법을 사용함으로써 페이지들은 실제 메모리에 올라가기 전에 가상 메모리에 할당되며, 필요한 페이지만 물리적인 메모리에 로드된다. 이를 통해 메모리 접근 시간을 최소화하고, 메모리의 효율성을 향상시킨다.

즉 프로세스가 실행될 때, 모든 페이지가 동시에 물리적인 메모리에 로드되지 않는다. 대신, 가상 메모리는 페이지 단위로 나뉘어진다. 프로그램이 필요로 하는 페이지들을 물리적인 메모리에 할당하는 방식을 사용한다는 것이다.

외부 단편화와 압축 작업을 해소할 수 있지만, 내부 단편화 문제의 비중이 늘어나게 된다. 예를들어 페이지 크기가 6KB 이고 프로세스 A 가 20KB 의 메모리를 요구한다면 3 개의 페이지 프레임(6KB * 3 = 18KB) 하고도 2KB 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 4KB(6KB - 2KB)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.

<br />
<br />

---

### 4. Segmentation

<img width="672" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/c590e3e5-7c69-4d12-b955-4d3d8be62502">

- Segment : 페이지 같은 개념이지만, 프로세스를 논리적 내용(코드의 함수, 변수, 표준 라이브러리...)을 기반으로 나눠서 메모리에 배치
- 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 (페이징과 다른 점)
  
- 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장


<img width="669" alt="image" src="https://github.com/1017yu/woojoo_land/assets/83483378/bae95995-909d-472f-ae6d-10c83cd63fca">

  ```
  기준(Base)은 세그먼트의 시작 물리 주소
  즉, 해당 세그먼트가 메모리에서 차지하는 물리적인 위치를 가리키는 갓이다.
  기준은 세그먼트가 메모리에 로드되어 실제 주소로 변환될 때 사용된다.

  한계(Limit)는 세그먼트의 크기를 나타낸다.
  세그먼트가 차지하는 메모리 공간의 크기를 제한하는 값으로, 기준 주소로부터 세그먼트의 크기를 나타냄.
  한계를 사용하여 세그먼트의 끝 부분을 결정하고 메모리 접근의 유효성을 검사할 수 있다.
  ```

세그먼트의 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)
