# 배경지식

## Map 자료형

- 데이터를 key-value 쌍으로 저장하는 자료형
- 자바스크립트의 객체가 가장 쉬운 예시
- 다른 언어에서는 딕셔너리라고도 불린다.
- map은 각 키(key)에 대해 고유한 값(value)을 가지고 있으며, 이를 통해 효율적인 데이터 검색이 가능함
- 자바스크립트의 new Map()도 map 자료형

| 전화번호(key) | 이름(value) |
| :-----------: | :---------: |
| 010-1111-1111 |    희태     |
| 010-2222-2222 |    정우     |
| 010-3333-3333 |    시우     |
| 010-4444-4444 |    하은     |
| 010-5555-5555 |    준희     |

```js
const phonNumber = {
  '010-1111-1111': '희태',
  '010-2222-2222': '정우',
  '010-3333-3333': '시우',
  '010-4444-4444': '하은',
  '010-5555-5555': '준희',
};
```

## hash table

- map을 구현하기 위한 방법 중 하나(다른 하나로 tree based가 있다)
- key값을 hash function으로 돌려서 hash value를 얻는다
- hash value를 배열의 index 값으로 사용한다
- 메모리에 다음과 같이 저장

```
Bucket 0: [1927, '010-1111-1111, '희태']
Bucket 1: [1837, '010-2222-2222', '정우']
...
```

- [hash, key, value] 뭉탱이를 bucket이라고 하며 bucket들은 서로 메모리공간상 인접해있다.
- bucket은 내부 data에 따라 다르지만 보통 몇바이트에서 수십바이트

## hash collision

- hash function은 문자열 input을 일정한 크기의 정수값으로 바꾸는 함수
- 당연하게도 input:output을 1:1로 대응하게 만들수가 없다
- 서로다른 key값이 hash function에 의해 동일한 hash value를 갖는 경우를 hash collision이라고 함
- ![image](https://github.com/CS-TeamStudy/CS_Study_for_Interview/assets/87072568/6f621067-ee83-4334-a673-c2a7532f4bdc)

# hash collision 해결 방법

## Separate Chaining 방식 (분리 연결법, open chaining)

![image](https://github.com/CS-TeamStudy/CS_Study_for_Interview/assets/87072568/79c7f921-6e59-4f25-8a3e-716f2f681fce)

- put('John Smith', '521-1234')
  - key값 'John Smith'을 hash function을 통해 hash value 152를 얻는다.
  - 해당 bucket에 ['John Smith', '521-1234' ]를 저장한다.
- get('Sam Doe')
  - key값 'Sam Doe'을 hash function을 통해 hash value 254를 얻는다.
  - 해당 bucket에 key('Sam Doe')와 검색 키('Sam Doe')가 일치하므로 value값 '521-5030'을 return 한다
- put('Sandra Dee')
  - key값 'Sandra Dee'을 hash function을 통해 hash value 152를 얻는다.
  - 해당 bucket의 key값('John Smith')과 'Sandra Dee'를 비교한다.
  - 일치하지 않으므로 해당 버킷에 새로운 버킷공간을 가리키는 주소를 저장하고 가리키는 버킷에 [ 'Sandra Dee', '521-9655' ]를 저장한다.
- delete('John Smith')
  - key값 'John Smith'을 hash function을 통해 hash value 152를 얻는다.
  - 해당 bucket의 key값('John Smith')와 검색키값('John Smith')를 비교한다.
  - 일치하므로 해당 버킷의 값을 지우며 link되어있던 Sandra Dee를 해당 bucket으로 옮긴다.

## Open adress 방식 (개방주소법)

![image](https://github.com/CS-TeamStudy/CS_Study_for_Interview/assets/87072568/017a55ec-9e9b-49a0-8204-8d2483a2f295)


- put('John Smith', '521-1234')
  - key값 'John Smith'을 hash function을 통해 hash value 873을 얻는다.
  - 해당 bucket에 ['John Smith', '521-1234' ]를 저장한다.
- get('Sam Doe')
  - key값 'Sam Doe'을 hash function을 통해 hash value 998을 얻는다.
  - 해당 bucket에 key('Sam Doe')와 검색 키('Sam Doe')가 일치하므로 value값 '521-5030'을 return 한다
- put('Sandra Dee')
  - key값 'Sandra Dee'을 hash function을 통해 hash value 873을 얻는다.
  - 해당 bucket의 key값('John Smith')과 'Sandra Dee'를 비교한다.
  - 일치하지 않으므로 해당 버킷 다음 bucket에 [ 'Sandra Dee', '521-9655' ]를 저장한다.
  - 만약 다음 버킷에도 값이 들어있다면 다음으로 이동한다.(linear probing의 경우)
    - 충돌이 발생하였을 때 다음 버킷을 찾는 방법에 따라 선형탐색(linear probing), 제곱탐색(Quadratic probing), 이중 해시(Double Hashing)으로 나뉜다.
- delete('John Smith')
  - key값 'John Smith'을 hash function을 통해 hash value 873을 얻는다.
  - 해당 bucket의 key값('John Smith')와 검색키값('John Smith')를 비교한다.
  - 일치하므로 해당 버킷의 값을 지우며 해당 칸에 더미 값을 넣는다.
    - 지금은 값이 없지만 삭제가 되었음을 명시
    - 명시를 하지 않은 경우 get('Sandra Dee')를 했을 때 값이 undefined가 된다.

# Hash bucket의 동적 확장(Resize)
