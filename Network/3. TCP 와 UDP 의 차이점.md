# TCP 와 UDP의 비교

## TCP 란? 
 -> TCP(Transmission Control Protocol)는 인터넷에서 데이터를 안정적으로 전송하기 위해 사용되는 프로토콜입니다. 
    TCP는 전송 계층에서 동작하며, 데이터의 신뢰성과 순서를 보장하여 효율적인 통신을 가능하게 합니다. 세계 통신표준으로 개발된 OSI 모형에서 4번째 계층인 “전송 계층(Transport Layer)” 이기도 합니다.
    전송 계층(Transport Layer) 에는 또 다른 프로토콜로 "UDP" 가 존재 합니다.

## TCP가 만들어진 이유
-> TCP 를 개발하게 된 이유는 군사적인 목적이 있다고 합니다. <br/>
미국 국방부에서 “ARPANET” 를 연구할때 전쟁이 발달해도 죽지 않고 정상적으로 동작하는 네트워크를 만드는것에 대해 관심을 갖었다고 합니다.<br/>
당시에 사용되었던 통신 방식은 “회선 교환” 방식이 였습니다. <br/>
Ex) 서울에서 부산으로 간다고 할때,  미리 이동할 경로를 ＂경부고속도로만 이용한다"로 정해놓는 방식<br/>
입니다.  하지만, 이러한 방식은 통신을 중계해 주던 곳이 망가지 거나 중간에 선 하나가 단락 되는 것만으로도 통신이 바로 끊어지는 상황이 벌어졌습니다.<br/>
따라 , 이러한 문제를 해결 하기위해 경로가 정해져 있지 않으며, 다른 곳으로 우회를 해서 갈 수 있는 방식 <br/>
즉,  서로 연결이 가능한 회선 하나만 남아 있어도 통신이 끊어지지 않고 계속 될수 있는 환경을 구축하도록 사용된것이 “ 패킷교환(Packet Switching) “ 방식 입니다. <br/>
하지만 패킷교환의 방식은 어떻게든 통신을 유지하는 것이 목적이므로 네트워크 환경의 안정성은 떨어질 수밖에 없었 습니다. <br/>
이로 인해 중간에 데이터가 유실되거나, 너무 늦게 전달되는 등 신뢰성이 떨어지는 문제점이 있었습니다.<br/> 
이러한 문제점들을 해결하고자 신뢰성을 보장할 수 있는 통신 규약을 연구해서 만든게 TCP 입니다.<br/>

## TCP특징
신뢰성: 데이터의 손실이나 손상을 최소화하기 위해 재전송과 에러 검출을 제공합니다.<br/>
순서 보장: 데이터 패킷이 전송되는 순서대로 재조립되어 수신자에게 정확한 데이터를 전달합니다.<br/>
흐름 제어: 발신자와 수신자 간의 데이터 전송 속도를 조절하여 네트워크 혼잡을 방지합니다.<br/>
혼잡 제어: 네트워크 혼잡을 감지하고 조절하여 데이터 전송의 효율성을 높입니다.<br/>

### 신뢰성 : TCP 연결수립(3 Way handshake)
TCP는 전화를 거는 것처럼 상대와 연결을 설정하고 통신을 시작 합니다.<br/> 
통신을 시작하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정 입니다.

#### 용어 
SYN -> 수신자가 발신자에게 연결 수락을 의미하는 신호입니다. 이 패킷에는 수신자가 전송할 데이터의 일련번호도 포함<br/>
ACK -> 데이터를 수신한 측이 송신한 데이터를 정상적으로 받았음을 알리는 신호 입니다.

<img width="500" alt="image" src="https://github.com/CS-TeamStudy/CS_Study_for_Interview/assets/101441685/507edacd-b53a-4395-9359-c694d0865ade">

#### [ STEP 1]
A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.<br/>
이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태, B서버는 Wait for Client 상태이다.

#### [ STEP 2]
B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고<br/>
A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.

#### [ STEP 3]
A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다.<br/>
이때의 B서버 상태가 ESTABLISHED 이다.<br/>
위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

### TCP 연결수립(4 Way handshake)
-> 3-Way handshake는 TCP의 연결<br/>
-> 4-Way handshake는 세션을 종료하기 위해 수행되는 절차입니다.

<img width="500" alt="image" src="https://github.com/hahahaday12/cs_test/assets/101441685/468ffd7b-598f-4d1e-bbe6-d6a0aebf6c9e">

#### [STEP 1]
클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 A클라이언트는  FIN-WAIT 상태가 된다.
 
#### [STEP 2] 
B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 B서버의 CLOSE_WAIT상태다.
 
#### [STEP 3]
연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 LAST-ACK이다.
 
#### [STEP 4]
클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.<br/>
A클라이언트의 상태가 FIN-WAIT ->TIME-WAIT 으로 변경된다.

### TCP: 흐름제어
송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.<br/>
송신 측이 수신 측보다 속도가 빠르면 문제가 발생한다.<br/>
수신 측에서 수신된 데이터를 처리해서 상위 계층으로 서비스 하는 속도보다 송신 측에서 보내는 데이터의 속도가더 빠르다면 수신 측에서는 제한된 저장용량을 초과하여 이후에 도착하는 데이터는 손실될 수 있다

#### 방법
1. 수신자 창(Sliding Window):<br/>
-> 수신자는 자신이 처리할 수 있는 데이터의 양을 나타내는 수신자 창을 유지합니다. <br/>
이 창수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.

#####  윈도우 크기 
-> 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며,  이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다.


#### 동작 방식
-> 윈도우에 포함된 패킷을 계속 전송하고, <br/>
 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨다음 패킷들을 전송한다.

<img width="500" alt="image" src="https://github.com/hahahaday12/cs_test/assets/101441685/4acb5bfc-4c03-40aa-960d-f92ecc668636">

2. Stop and Wait<br/>
-> 매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법이다. <br/>
그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.

<img width="200" alt="image" src="https://github.com/hahahaday12/cs_test/assets/101441685/4f9405c3-16db-42a0-ac95-c3eddf3e0d19">

⭐요약 ⭐<br/>
-> TCP 흐름 제어는 발신자에게 수신자의 처리 속도를 알려주는 방식으로 조절합니다. 수신자의 처리 능력을 고려하여 발신자가 <br/>
데이터를 전송하는 속도를 제어함으로써 네트워크 혼잡을 방지하고 데이터의 신뢰성을 유지 합니다.

### TCP: 혼잡제어
-> 데이터의 양이 초과되면 초과된 데이터는 라우터가 처리하지 못 합니다. <br/>
이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 합니다. <br/>
이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방하는것을 <b>혼잡제어<b/>  라고 합니다.

#### 1. AIMD(Additive Increse/Multicative Decrease)
-> 우리 말로 직역하면 합 증가/곱 감소 방식입니다. <br/>
AIMD 방식은 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송 합니다.<br/>
실패하면 윈도우 크기를 반으로 줄입니다.  단점:  시간이 오래걸림. 

#### 2. Slow Start (느린 시작)
-> Slow Start는 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식 입니다. <br>
ACK가 도착할 때마다 윈도우 크기를 증가 합니다.

## UDP 란? 
-> 데이터 신뢰성을 보장하기 위한 방식인 TCP 를 사용하였지만, 실시간 스트리밍 서비스에서 걸림돌로 작용했다. 이를 해결하기 위해서 제시된 것이 UDP 이다.

### 1. 비연결성 (Connectionless): <br/>
UDP는 연결 설정 절차를 거치지 않고 데이터를 전송합니다. 데이터 그램(Datagram) 단위로 독립적으로 처리되며, 각각의 패킷은 독립적으로 처리됩니다. <br/>
이는 TCP와 달리 UDP가 연결을 설정하지 않고 데이터를 전송함을 의미합니다.

### 2. 신뢰성 보장하지 않음: <br/>
UDP는 데이터 전송에 대한 신뢰성을 보장하지 않습니다. <br/>
패킷의 손실, 중복, 순서 변경 등의 문제가 발생할 수 있습니다. 이는 UDP가 상위 응용 프로그램에서 직접 신뢰성을 제어하도록 하는 대신, 빠른 전송을 위해 부담을 줄이기 위해 선택된 특징입니다.

### 3. 순서 보장하지 않음:<br/>
UDP는 패킷이 전송되는 순서를 보장하지 않습니다.<br/>
따라서 송신측에서 보낸 순서와는 다르게 수신측에서 패킷이 도착할 수 있습니다. 이는 데이터의 순서가 중요하지 않거나, 응용 프로그램에서 직접 처리할 수 있는 경우에 유용합니다.

### 4. 경량화: <br/>
UDP는 TCP보다 더 경량화되어 있으며, 데이터 전송에 필요한 오버헤드가 적습니다. 이는 UDP가 더 빠른 전송 속도를 제공할 수 있는 이유 중 하나입니다.

### 5. 멀티캐스트 및 브로드캐스트 지원: <br>
UDP는 멀티캐스트(Multicast) 및 브로드캐스트(Broadcast)와 같은 다중 대상 전송을 지원합니다. 이는 동일한 데이터를 여러 대상에게 동시에 전송해야 하는 상황에서 유용합니다.

⭐요약 ⭐<br/>
-> TCP 보다 간단하고 빠름. 단, 신뢰성이나 순서보장이 중요하지 않은 경우만 적합

### 👀 한눈에 보기~~

#### TCP vs UDP 비교

<img width="500" alt="image" src="https://github.com/hahahaday12/cs_test/assets/101441685/8bdc41e7-8751-4264-a9c1-82c02d3ca13d">
